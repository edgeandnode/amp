pub use crate::proto::sf::ethereum::r#type::v2 as pbethereum;
use crate::{dataset::DatasetDef, Error};
pub mod pb_to_rows;
pub mod tables;

use common::Dataset;

pub fn dataset(dataset_cfg: toml::Value) -> Result<Dataset, Error> {
    let dataset_def: DatasetDef = dataset_cfg.try_into()?;
    Ok(Dataset {
        kind: dataset_def.kind,
        name: dataset_def.name,
        tables: tables::all(&dataset_def.network),
    })
}

#[tokio::test]
async fn print_schema_to_readme() {
    use common::catalog::physical::Catalog;
    use common::config::Config;
    use common::Dataset;
    use common::QueryContext;
    use fs_err as fs;
    use std::fmt::Write;
    use std::sync::Arc;

    let dataset = Dataset {
        kind: crate::DATASET_KIND.to_string(),
        name: "test_dataset".to_string(),
        tables: tables::all("test_network"),
    };
    let config = Config::in_memory();

    let env = Arc::new((config.make_runtime_env()).unwrap());
    let mut catalog = Catalog::empty();
    catalog.register(&dataset, config.data_store).unwrap();
    let context = QueryContext::for_catalog(catalog, env).unwrap();

    let mut out = String::new();
    writeln!(out, "# Schema").unwrap();
    writeln!(out, "Autogenerated file.").unwrap();
    for (table, pretty_schema) in context.print_schema().await.unwrap() {
        writeln!(out, "## {}", table.table_name()).unwrap();
        writeln!(out, "````").unwrap();
        writeln!(out, "{}", pretty_schema).unwrap();
        writeln!(out, "````").unwrap();
    }

    let path = "src/evm/README.md";
    fs::write(path, out).unwrap();
}
