#!/usr/bin/env bash
set -eo pipefail

REPO="edgeandnode/project-nozzle"
REF="main"
VERSION="1.0.0"

BASE=${XDG_CONFIG_HOME:-$HOME}
DIR=${DIR-"$BASE/.nozzle"}
BIN="$DIR/bin"

# OPTIONAL: Needed for private repository access. Can be deleted once the repository is public.
BEARER="${GITHUB_TOKEN:-}"

OPT_VERSION=""
OPT_BRANCH=""
OPT_COMMIT=""
OPT_PR=""
OPT_PATH=""
OPT_REPO=""
OPT_JOBS=""
OPT_FORCE=false
OPT_PLATFORM=""
OPT_ARCH=""

download_file() {
  local path=$1
  local output=$2

  if [ -n "$BEARER" ]; then
    if ! curl -sSfL \
      -H "Authorization: Bearer $BEARER" \
      -H "Accept: application/vnd.github.v3.raw" \
      "https://api.github.com/repos/$REPO/contents/$path?ref=$REF" \
      -o "$output"; then
      return 1
    fi
  else
    if ! curl -sSfL \
      "https://raw.githubusercontent.com/$REPO/$REF/$path" \
      -o "$output"; then
      return 1
    fi
  fi
  return 0
}

main() {
  need_cmd curl

  while [[ $# -gt 0 ]]; do
    case $1 in
      -h|--help)
        usage
        exit 0
        ;;
      -v|--version)
        echo "$VERSION"
        exit 0
        ;;
      -U|--update)
        update_nozzleup
        exit 0
        ;;
      -i|--install)
        shift
        OPT_VERSION=$1
        ;;
      -l|--list)
        list_versions
        exit 0
        ;;
      -u|--use)
        shift
        use_version "$1"
        exit 0
        ;;
      -b|--branch)
        shift
        OPT_BRANCH=$1
        ;;
      -C|--commit)
        shift
        OPT_COMMIT=$1
        ;;
      -P|--pr)
        shift
        OPT_PR=$1
        ;;
      -p|--path)
        shift
        OPT_PATH=$1
        ;;
      -r|--repo)
        shift
        OPT_REPO=$1
        ;;
      -j|--jobs)
        shift
        OPT_JOBS=$1
        ;;
      -f|--force)
        OPT_FORCE=true
        ;;
      --arch)
        shift
        OPT_ARCH=$1
        ;;
      --platform)
        shift
        OPT_PLATFORM=$1
        ;;
      *)
        err "unknown option: $1"
        ;;
    esac
    shift
  done

  # Determine installation method
  if [ -n "$OPT_PATH" ]; then
    build_from_local "$OPT_PATH"
  elif [ -n "$OPT_REPO" ]; then
    build_from_repo "$OPT_REPO"
  elif [ -n "$OPT_BRANCH" ]; then
    build_from_branch "$OPT_BRANCH"
  elif [ -n "$OPT_COMMIT" ]; then
    build_from_commit "$OPT_COMMIT"
  elif [ -n "$OPT_PR" ]; then
    build_from_pr "$OPT_PR"
  elif [ -n "$OPT_VERSION" ]; then
    install_binary "$OPT_VERSION"
  else
    # Default: install latest version
    OPT_VERSION=$(get_latest_version)
    say "Installing latest version: $OPT_VERSION"
    install_binary "$OPT_VERSION"
  fi
}

usage() {
  cat <<EOF
nozzleup - The nozzle toolchain installer

USAGE:
    nozzleup [OPTIONS]

OPTIONS:
    -h, --help                 Print help information
    -v, --version              Print current nozzleup version
    -U, --update               Update nozzleup itself
    -i, --install <VERSION>    Install a specific version from binaries
    -l, --list                 List installed versions
    -u, --use <VERSION>        Switch to a specific installed version
    -b, --branch <BRANCH>      Build and install from a specific branch
    -C, --commit <COMMIT>      Build and install from a specific commit
    -P, --pr <NUMBER>          Build and install from a specific pull request
    -p, --path <PATH>          Build and install from a local repository
    -r, --repo <REPO>          Build and install from a remote repository
    -j, --jobs <N>             Number of CPU cores to use when building (default: all)
    -f, --force                Skip SHA256 verification (insecure)
    --arch <ARCH>              Override architecture detection (x86_64, aarch64)
    --platform <PLATFORM>      Override platform detection (linux, darwin)

ENVIRONMENT VARIABLES:
    GITHUB_TOKEN               GitHub personal access token for private repositories

EXAMPLES:
    # Install latest version
    nozzleup

    # Install specific version
    nozzleup --install v0.1.0

    # Install from a branch
    nozzleup --branch main

    # Install from a Pull Request
    nozzleup --pr 123

    # Install from a commit
    nozzleup --commit abc123

    # Install from local repository
    nozzleup --path /path/to/nozzle

    # Install from remote repository
    nozzleup --repo user/fork

    # List installed versions
    nozzleup --list

    # Switch to specific version
    nozzleup --use v0.1.0
EOF
}

update_nozzleup() {
  say "Updating nozzleup ..."

  local nozzleup_path="$BIN/nozzleup"
  local temp_path="$nozzleup_path.tmp"

  if ! download_file "nozzleup/nozzleup" "$temp_path"; then
    err "Failed to download update"
  fi

  chmod +x "$temp_path"
  mv "$temp_path" "$nozzleup_path"

  say "Updated successfully"
}

get_latest_version() {
  local latest
  local args=(-sSf)

  if [ -n "$BEARER" ]; then
    args+=(-H "Authorization: Bearer $BEARER")
  fi

  latest=$(curl "${args[@]}" "https://api.github.com/repos/$REPO/releases/latest" 2>/dev/null | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')

  if [ -z "$latest" ]; then
    err "Failed to get latest version"
  fi

  echo "$latest"
}

install_binary() {
  local version=$1
  local platform arch binary_url

  platform=$(get_platform)
  arch=$(get_arch)

  # Construct artifact name
  local artifact_name="nozzle-${platform}-${arch}"

  say "Downloading $version for $platform-$arch ..."

  # Download to temp location first
  local temp_binary
  temp_binary=$(mktemp)
  trap "rm -f $temp_binary" EXIT

  # For private repos, we need to use the GitHub API to download release assets
  if [ -n "$BEARER" ]; then
    # Check if release exists first
    local release_url="https://api.github.com/repos/$REPO/releases/tags/${version}"
    if ! curl -sSf -H "Authorization: Bearer $BEARER" "$release_url" -o /dev/null 2>/dev/null; then
      err "Release $version not found"
    fi

    # Get asset ID from GitHub API
    local asset_id
    asset_id=$(curl -sSf -H "Authorization: Bearer $BEARER" "$release_url" 2>/dev/null \
      | grep -B 3 "\"name\": \"$artifact_name\"" \
      | grep '"id"' \
      | head -1 \
      | sed -E 's/.*"id": ([0-9]+).*/\1/')

    if [ -z "$asset_id" ]; then
      err "Binary '$artifact_name' not found in release $version"
    fi

    # Download via API with Accept header for binary content
    if ! curl -sSfL \
      -H "Authorization: Bearer $BEARER" \
      -H "Accept: application/octet-stream" \
      "https://api.github.com/repos/$REPO/releases/assets/$asset_id" \
      -o "$temp_binary"; then
      err "Could not download binary for $artifact_name from release $version"
    fi
  else
    # Public repo: use direct download URL
    binary_url="https://github.com/$REPO/releases/download/${version}/${artifact_name}"

    if ! curl -sSfL "$binary_url" -o "$temp_binary"; then
      err "Release $version not found or does not contain binary for $platform-$arch"
    fi
  fi

  # Verify the downloaded file is not empty
  if [ ! -s "$temp_binary" ]; then
    err "Downloaded binary is empty"
  fi

  # Verify SHA256 if not forced to skip
  if [ "$OPT_FORCE" = false ]; then
    verify_sha256 "$temp_binary" "$binary_url"
  fi

  # Download successful, now create version directory
  local version_dir="$DIR/versions/$version"
  mkdir -p "$version_dir"

  local binary_path="$version_dir/nozzle"
  mv "$temp_binary" "$binary_path"
  chmod +x "$binary_path"

  # Symlink to bin directory
  ensure ln -sf "$binary_path" "$BIN/nozzle"

  # Record installed version
  echo "$version" > "$DIR/.current_version"

  say "Successfully installed nozzle ($version)"
  say "Run 'nozzle --version' to verify installation"
}

verify_sha256() {
  local binary_path=$1
  local binary_url=$2
  local checksum_url="${binary_url}.sha256"

  say "Verifying SHA256 checksum ..."

  local args=(-sSfL)
  if [ -n "$BEARER" ]; then
    args+=(-H "Authorization: Bearer $BEARER")
  fi

  local expected_sum
  expected_sum=$(curl "${args[@]}" "$checksum_url" 2>/dev/null | awk '{print $1}')

  if [ -z "$expected_sum" ]; then
    warn "Could not download checksum file, skipping verification"
    return
  fi

  local actual_sum
  if command -v sha256sum >/dev/null 2>&1; then
    actual_sum=$(sha256sum "$binary_path" | awk '{print $1}')
  elif command -v shasum >/dev/null 2>&1; then
    actual_sum=$(shasum -a 256 "$binary_path" | awk '{print $1}')
  else
    warn "No SHA256 tool found, skipping verification"
    return
  fi

  if [ "$expected_sum" != "$actual_sum" ]; then
    err "SHA256 verification failed. Expected: $expected_sum, Got: $actual_sum"
  fi

  say "SHA256 verification successful"
}

build_from_local() {
  local path=$1

  if [ ! -d "$path" ]; then
    err "Local path does not exist: $path"
  fi

  say "Building from local path: $path"
  need_cmd cargo

  cd "$path"
  build_and_install "local"
}

build_from_repo() {
  local repo=$1
  need_cmd git
  need_cmd cargo

  say "Cloning repository: $repo"

  local temp_dir
  temp_dir=$(mktemp -d)
  trap "rm -rf $temp_dir" EXIT

  git clone "https://github.com/$repo.git" "$temp_dir"
  cd "$temp_dir"

  build_and_install "repo-$repo"
}

build_from_branch() {
  local branch=$1
  need_cmd git
  need_cmd cargo

  say "Building from branch: $branch"

  local temp_dir
  temp_dir=$(mktemp -d)
  trap "rm -rf $temp_dir" EXIT

  git clone --branch "$branch" "https://github.com/$REPO.git" "$temp_dir"
  cd "$temp_dir"

  build_and_install "branch-$branch"
}

build_from_commit() {
  local commit=$1
  need_cmd git
  need_cmd cargo

  say "Building from commit: $commit"

  local temp_dir
  temp_dir=$(mktemp -d)
  trap "rm -rf $temp_dir" EXIT

  git clone "https://github.com/$REPO.git" "$temp_dir"
  cd "$temp_dir"
  git checkout "$commit"

  build_and_install "commit-$commit"
}

build_from_pr() {
  local pr=$1
  need_cmd git
  need_cmd cargo

  say "Building from pull request #$pr"

  local temp_dir
  temp_dir=$(mktemp -d)
  trap "rm -rf $temp_dir" EXIT

  git clone "https://github.com/$REPO.git" "$temp_dir"
  cd "$temp_dir"
  git fetch origin "pull/$pr/head:pr-$pr"
  git checkout "pr-$pr"

  build_and_install "pr-$pr"
}

build_and_install() {
  local version_label=$1

  say "Building nozzle ..."

  local build_cmd="cargo build --release -p nozzle"

  if [ -n "$OPT_JOBS" ]; then
    build_cmd="$build_cmd -j $OPT_JOBS"
  fi

  ensure $build_cmd

  # Determine target directory
  local binary_source="target/release/nozzle"

  if [ ! -f "$binary_source" ]; then
    err "Build succeeded but binary not found at $binary_source"
  fi

  # Create version-specific directory
  local version_dir="$DIR/versions/$version_label"
  mkdir -p "$version_dir"

  local binary_path="$version_dir/nozzle"

  # Copy binary
  cp "$binary_source" "$binary_path"
  chmod +x "$binary_path"

  # Symlink to bin directory
  ensure ln -sf "$binary_path" "$BIN/nozzle"

  # Record installed version
  echo "$version_label" > "$DIR/.current_version"

  say "Successfully built and installed nozzle ($version_label)"
  say "Run 'nozzle --version' to verify installation"
}

list_versions() {
  local versions_dir="$DIR/versions"

  if [ ! -d "$versions_dir" ]; then
    say "No versions installed"
    return
  fi

  local current_version
  if [ -f "$DIR/.current_version" ]; then
    current_version=$(cat "$DIR/.current_version")
  fi

  say "Installed versions:"
  for version_path in "$versions_dir"/*; do
    if [ -d "$version_path" ]; then
      local version=$(basename "$version_path")
      if [ "$version" = "$current_version" ]; then
        say "  * $version (current)"
      else
        say "    $version"
      fi
    fi
  done
}

use_version() {
  local version=$1
  local version_dir="$DIR/versions/$version"

  if [ ! -d "$version_dir" ]; then
    err "Version $version is not installed. Run 'nozzleup --install $version' to install it"
  fi

  local binary_path="$version_dir/nozzle"
  ensure ln -sf "$binary_path" "$BIN/nozzle"
  echo "$version" > "$DIR/.current_version"

  say "Switched to nozzle $version"
}

get_platform() {
  if [ -n "$OPT_PLATFORM" ]; then
    echo "$OPT_PLATFORM"
    return
  fi

  local platform
  platform=$(uname -s | tr '[:upper:]' '[:lower:]')

  case $platform in
    linux)
      echo "linux"
      ;;
    darwin)
      echo "darwin"
      ;;
    *)
      err "Unsupported platform: $platform"
      ;;
  esac
}

get_arch() {
  if [ -n "$OPT_ARCH" ]; then
    echo "$OPT_ARCH"
    return
  fi

  local arch
  arch=$(uname -m)

  case $arch in
    x86_64|amd64)
      echo "x86_64"
      ;;
    arm64|aarch64)
      echo "aarch64"
      ;;
    *)
      err "Unsupported architecture: $arch"
      ;;
  esac
}

say() {
  echo "nozzleup: $1"
}

warn() {
  say "warning: ${1}" >&2
}

err() {
  say "error: $1" >&2
  exit 1
}

need_cmd() {
  if ! command -v "$1" > /dev/null 2>&1; then
    err "Need '$1' (command not found)"
  fi
}

ensure() {
  if ! "$@"; then
    err "Command failed: $*"
  fi
}

main "$@"
