pub use crate::proto::sf::ethereum::r#type::v2 as pbethereum;
use common::{DataSchema, Dataset};

pub mod pb_to_rows;
pub mod tables;

pub fn dataset(network: String) -> Dataset {
    Dataset {
        name: "evm-firehose".to_string(),
        network,
        data_schema: DataSchema {
            tables: tables::all(),
        },
    }
}

#[tokio::test]
async fn print_schema_to_readme() {
    use common::config::Config;
    use common::DatasetContext;
    use fs_err as fs;
    use std::fmt::Write;
    use std::sync::Arc;
    use url::Url;

    let dataset = dataset("whatever".to_string());
    let url = Url::parse("memory://test_url/").unwrap();
    let object_store = Arc::new(object_store::memory::InMemory::new());
    let config = Config::location_only("/var/tmp".to_string());
    let env = Arc::new((config.to_runtime_env()).unwrap());
    let context = DatasetContext::with_object_store(env, dataset, vec![], url, object_store)
        .await
        .unwrap();

    let mut out = String::new();
    writeln!(out, "# Schema").unwrap();
    writeln!(out, "Autogenerated file.").unwrap();
    for (table, pretty_schema) in context.print_schema().await.unwrap() {
        writeln!(out, "## {}", table.name).unwrap();
        writeln!(out, "````").unwrap();
        writeln!(out, "{}", pretty_schema).unwrap();
        writeln!(out, "````").unwrap();
    }

    let existing = fs::read_to_string("evm/README.md").unwrap_or_default();

    // Only write if the content has changed.
    if existing != out {
        fs::write("src/evm/README.md", out).unwrap();
    }
}
