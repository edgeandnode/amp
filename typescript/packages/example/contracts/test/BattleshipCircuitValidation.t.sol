// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {Groth16Verifier as BoardVerifier} from "../src/BattleshipBoardVerifier.sol";
import {Groth16Verifier as ShotVerifier} from "../src/BattleshipShotVerifier.sol";

contract BattleshipCircuitValidationTest is Test {
    BoardVerifier public boardVerifier;
    ShotVerifier public shotVerifier;

    function setUp() public {
        boardVerifier = new BoardVerifier();
        shotVerifier = new ShotVerifier();
        console.log("Deployed board verifier at:", address(boardVerifier));
        console.log("Deployed shot verifier at:", address(shotVerifier));
    }

    function test_VerifierContractsDeployed() view public {
        assertTrue(address(boardVerifier) != address(0), "Board verifier should be deployed");
        assertTrue(address(shotVerifier) != address(0), "Shot verifier should be deployed");
    }

    function test_BoardVerifierInterface() view public {
        // Test that the verifier has the expected interface
        // We'll test with dummy values - real proofs will be generated by external script
        uint256[2] memory a = [uint256(1), uint256(2)];
        uint256[2][2] memory b = [[uint256(3), uint256(4)], [uint256(5), uint256(6)]];
        uint256[2] memory c = [uint256(7), uint256(8)];
        uint256[1] memory input = [uint256(123456789)]; // dummy commitment

        // This should return false for invalid proof, but shouldn't revert
        bool result = boardVerifier.verifyProof(a, b, c, input);
        // We expect false since this is not a valid proof
        assertFalse(result, "Invalid proof should return false");
    }

    function test_ShotVerifierInterface() view public {
        // Test that the verifier has the expected interface with 7 public signals
        uint256[2] memory a = [uint256(1), uint256(2)];
        uint256[2][2] memory b = [[uint256(3), uint256(4)], [uint256(5), uint256(6)]];
        uint256[2] memory c = [uint256(7), uint256(8)];
        uint256[7] memory publicSignals = [
            uint256(123456789), // previousCommitment
            uint256(123456790), // newCommitment
            uint256(5), // targetX
            uint256(5), // targetY
            uint256(0), // claimedResult (miss)
            uint256(255), // claimedShipId
            uint256(5) // claimedRemainingShips
        ];

        // This should return false for invalid proof, but shouldn't revert
        bool result = shotVerifier.verifyProof(a, b, c, publicSignals);
        // We expect false since this is not a valid proof
        assertFalse(result, "Invalid proof should return false");
    }

    // Note: Real proof validation tests will be added via external script
    // that generates actual proofs and calls these verifiers
}
