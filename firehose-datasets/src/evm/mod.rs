pub use crate::proto::sf::ethereum::r#type::v2 as pbethereum;
use common::Dataset;

pub mod pb_to_rows;
pub mod tables;

pub fn dataset(network: String) -> Dataset {
    Dataset {
        name: "evm_firehose".to_string(),
        network,
        tables: tables::all(),
    }
}

#[tokio::test]
async fn print_schema_to_readme() {
    use common::catalog::physical::Catalog;
    use common::config::Config;
    use common::QueryContext;
    use fs_err as fs;
    use std::fmt::Write;
    use std::sync::Arc;
    use url::Url;

    let dataset = dataset("whatever".to_string());
    let url = Url::parse("memory://test_url/").unwrap();
    let object_store = Arc::new(object_store::memory::InMemory::new());
    let config = Config::location_only("/var/tmp".to_string());
    let env = Arc::new((config.to_runtime_env()).unwrap());
    let mut catalog = Catalog::empty(url, object_store).unwrap();
    catalog.register(&dataset).unwrap();
    let context = QueryContext::for_catalog(catalog, env).await.unwrap();

    let mut out = String::new();
    writeln!(out, "# Schema").unwrap();
    writeln!(out, "Autogenerated file.").unwrap();
    for (table, pretty_schema) in context.print_schema().await.unwrap() {
        writeln!(out, "## {}", table.table_name()).unwrap();
        writeln!(out, "````").unwrap();
        writeln!(out, "{}", pretty_schema).unwrap();
        writeln!(out, "````").unwrap();
    }

    let path = "src/evm/README.md";
    fs::write(path, out).unwrap();
}
