# Streaming join test with blockchain reorganization
#
# This test validates that streaming queries with JOINs correctly handle
# blockchain reorganizations, delivering updated results after reorg.
#
# Flow:
# 1. Mine initial blocks and register streaming join
# 2. Take initial join results
# 3. Trigger reorg (removes some blocks)
# 4. Mine new blocks on the new fork
# 5. Verify join results reflect the reorganized chain

- anvil: {}

# Mine initial blocks (anvil starts with block 0)
- name: mine_initial
  mine: 5

# Dump to make data available
- name: dump_initial
  dataset: _/anvil_rpc@0.0.0
  end: 5

# Register the streaming join query (self-join on blocks via parent_hash)
- name: register_streaming_join
  stream: |
    SELECT child.block_num, parent.block_num as parent_num
    FROM anvil_rpc.blocks child
    JOIN anvil_rpc.blocks parent ON child.parent_hash = parent.hash
    SETTINGS stream = true

# Take initial join results - blocks 1-5 each joined with their parent
- name: take_initial_join
  stream: register_streaming_join
  take: 5
  results: |
    [
      {"block_num": 1, "parent_num": 0},
      {"block_num": 2, "parent_num": 1},
      {"block_num": 3, "parent_num": 2},
      {"block_num": 4, "parent_num": 3},
      {"block_num": 5, "parent_num": 4}
    ]

# Trigger reorg - removes last 2 blocks (4 and 5)
- name: trigger_reorg
  reorg: 2

# Mine new blocks on the reorganized chain
- name: mine_after_reorg
  mine: 3

# Dump the reorganized chain state
- name: dump_after_reorg
  dataset: _/anvil_rpc@0.0.0
  end: 6

# Take incremental join results after reorg
# Should see blocks 4, 5, 6 with their new parent relationships
- name: take_after_reorg
  stream: register_streaming_join
  take: 3
  results: |
    [
      {"block_num": 4, "parent_num": 3},
      {"block_num": 5, "parent_num": 4},
      {"block_num": 6, "parent_num": 5}
    ]
