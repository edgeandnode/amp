// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {Battleship} from "../src/Battleship.sol";
import {MockTestBase} from "./helpers/MockTestBase.sol";

/**
 * @title BattleshipIntegration Test Suite
 * @dev Full game scenarios and integration testing for Battleship contract
 */
contract BattleshipIntegrationTest is MockTestBase {
    // ═══════════════════════════════════════════════════════════════════
    // Complete Game Scenarios
    // ═══════════════════════════════════════════════════════════════════

    function test_ActualQuickVictory() public {
        uint256 gameId = setupTwoPlayerGame(alice, bob, 2 ether, alice);

        // Alice attacks first
        vm.prank(alice);
        bs.attack(gameId, 3, 4);

        // Bob responds with HIT and counter-attacks
        respondAndCounter(gameId, bob, Battleship.Impact.HIT, 5, 6);

        // Alice responds with SUNK (but not final ship) and counter-attacks
        respondAndCounterWithShips(gameId, alice, Battleship.Impact.SUNK, 7, 8, 2); // 2 ships remaining

        // Bob responds with MISS and counter-attacks
        respondAndCounter(gameId, bob, Battleship.Impact.MISS, 1, 2);

        // Alice responds with SUNK and it's the FINAL ship - game should end automatically
        // NOTE: The winner will be Bob (lastPlayer/attacker) since Alice is defending
        uint256 aliceBalanceBeforeWin = alice.balance;
        uint256 bobBalanceBeforeWin = bob.balance;

        respondAndCounterWithShips(gameId, alice, Battleship.Impact.SUNK, 9, 0, 0); // 0 ships left - GAME OVER

        // Verify game ended correctly with automatic victory
        assertTrue(bs.isGameEnded(gameId));

        Battleship.Game memory gameState = bs.getGameInfo(gameId);
        assertEq(gameState.prizePool, 0); // Prize pool emptied
        assertEq(gameState.winner, bob); // Bob was the attacker (lastPlayer) who gets the win

        // Verify Bob got the full payout (4 ether total)
        assertEq(bob.balance, bobBalanceBeforeWin + 4 ether);
        assertEq(alice.balance, aliceBalanceBeforeWin); // Alice gets nothing despite sinking the final ship
    }

    function test_ConcurrentGamesIndependence() public {
        // Create two concurrent games with different stakes and players
        uint256 game1 = setupTwoPlayerGame(alice, bob, 1 ether, alice);
        uint256 game2 = setupTwoPlayerGame(alice, charlie, 3 ether, charlie);

        // Verify games are independent with different stakes
        Battleship.Game memory gameState1 = bs.getGameInfo(game1);
        Battleship.Game memory gameState2 = bs.getGameInfo(game2);
        assertEq(gameState1.prizePool, 2 ether);
        assertEq(gameState2.prizePool, 6 ether);

        // Play moves in game1 (Alice vs Bob)
        vm.prank(alice);
        bs.attack(game1, 1, 1);
        respondAndCounter(game1, bob, Battleship.Impact.HIT, 2, 2);

        // Play moves in game2 (Charlie vs Alice)
        vm.prank(charlie);
        bs.attack(game2, 5, 5);
        respondAndCounter(game2, alice, Battleship.Impact.MISS, 7, 7);

        // Verify games remain independent - moves in one don't affect the other
        Battleship.Game memory updatedGameState1 = bs.getGameInfo(game1);
        Battleship.Game memory updatedGameState2 = bs.getGameInfo(game2);

        assertEq(updatedGameState1.lastShotX, 2);
        assertEq(updatedGameState1.lastShotY, 2);
        assertEq(updatedGameState1.lastPlayer, bob);

        assertEq(updatedGameState2.lastShotX, 7);
        assertEq(updatedGameState2.lastShotY, 7);
        assertEq(updatedGameState2.lastPlayer, alice);

        // End game1 while game2 continues
        vm.prank(alice);
        bs.forfeitGame(game1);

        // Verify only game1 ended, game2 still active
        assertTrue(bs.isGameEnded(game1));
        assertFalse(bs.isGameEnded(game2));

        // Bob gets game1 payout, game2 stakes unchanged
        Battleship.Game memory endGameState1 = bs.getGameInfo(game1);
        Battleship.Game memory endGameState2 = bs.getGameInfo(game2);
        assertEq(endGameState1.prizePool, 0); // Game1 pool emptied
        assertEq(endGameState2.prizePool, 6 ether); // Game2 pool unchanged
    }

    function test_InvalidMoveSequences() public {
        uint256 gameId = setupTwoPlayerGame(alice, bob, 1 ether, alice);
        Battleship.ImpactProof memory proof;

        // Alice makes initial attack
        vm.prank(alice);
        bs.attack(gameId, 2, 3);

        // Test 1: Alice tries to attack again without waiting for Bob's response
        vm.expectRevert(Battleship.InvalidMove.selector);
        vm.prank(alice);
        bs.attack(gameId, 4, 5);

        // Test 2: Bob tries to respond when Alice should respond (wrong turn)
        respondAndCounter(gameId, bob, Battleship.Impact.HIT, 6, 7);

        // Now Alice should respond, but Bob tries to respond again
        proof = getMockShotProof(gameId, bob, Battleship.Impact.MISS);
        vm.expectRevert(Battleship.NotYourTurn.selector);
        vm.prank(bob);
        bs.respondAndCounter(gameId, proof, 8, 9);

        // Test 3: Alice responds properly
        respondAndCounter(gameId, alice, Battleship.Impact.MISS, 1, 1);

        // Test 4: Try to attack with invalid coordinates (>= 10)
        proof = getMockShotProof(gameId, bob, Battleship.Impact.HIT);
        vm.expectRevert(Battleship.InvalidCoordinates.selector);
        vm.prank(bob);
        bs.respondAndCounter(gameId, proof, 10, 5);

        proof = getMockShotProof(gameId, bob, Battleship.Impact.HIT);
        vm.expectRevert(Battleship.InvalidCoordinates.selector);
        vm.prank(bob);
        bs.respondAndCounter(gameId, proof, 5, 10);

        // Test 5: Valid move to continue game
        respondAndCounter(gameId, bob, Battleship.Impact.HIT, 0, 0);

        // Verify game is still active and properly tracks moves
        assertFalse(bs.isGameEnded(gameId));
        Battleship.Game memory gameState = bs.getGameInfo(gameId);
        assertEq(gameState.lastShotX, 0);
        assertEq(gameState.lastShotY, 0);
        assertEq(gameState.lastPlayer, bob);
    }

    function test_CompleteGameWithForfeit() public {
        uint256 gameId = setupTwoPlayerGame(alice, bob, 3 ether, alice);

        vm.prank(alice);
        bs.attack(gameId, 0, 1);

        respondAndCounter(gameId, bob, Battleship.Impact.MISS, 2, 3);
        respondAndCounter(gameId, alice, Battleship.Impact.HIT, 4, 5);
        respondAndCounter(gameId, bob, Battleship.Impact.MISS, 6, 7);
        respondAndCounter(gameId, alice, Battleship.Impact.SUNK, 8, 9);
        respondAndCounter(gameId, bob, Battleship.Impact.HIT, 1, 0);
        respondAndCounter(gameId, alice, Battleship.Impact.MISS, 3, 2);

        // One player forfeits
        uint256 aliceInitialBalance = alice.balance;
        uint256 bobInitialBalance = bob.balance;

        vm.expectEmit(true, true, false, true);
        emit Battleship.GameEnded(gameId, bob);

        vm.prank(alice);
        bs.forfeitGame(gameId);

        // Verify game ended and payout
        assertTrue(bs.isGameEnded(gameId));
        Battleship.Game memory gameState = bs.getGameInfo(gameId);
        assertEq(gameState.winner, bob);
        assertEq(gameState.prizePool, 0);
        assertEq(bob.balance, bobInitialBalance + 6 ether);
        assertEq(alice.balance, aliceInitialBalance); // Alice forfeited, no additional loss
    }

    // ═══════════════════════════════════════════════════════════════════
    // Economic Tests
    // ═══════════════════════════════════════════════════════════════════

    function test_StakeRefund_GameNotStarted() public {
        uint256 stake = 5 ether;
        uint256 gameId = createGame(alice, stake);
        uint256 aliceBalanceAfterCreate = alice.balance;

        // Game exists but not started
        assertTrue(bs.isGameValid(gameId));
        assertFalse(bs.isGameStarted(gameId));
        assertFalse(bs.isGameEnded(gameId));

        // Alice can cancel the game and get her stake back
        vm.prank(alice);
        bs.cancelGame(gameId);

        // Verify Alice got her full stake refunded
        assertEq(alice.balance, aliceBalanceAfterCreate + stake);

        // Game should no longer be valid (cancelled games are invalid)
        assertFalse(bs.isGameValid(gameId));

        // Prize pool should be emptied
        Battleship.Game memory cancelledGame = bs.getGameInfo(gameId);
        assertEq(cancelledGame.prizePool, 0);

        // Test that only creator can cancel
        uint256 gameId2 = createGame(alice, stake);
        vm.expectRevert(Battleship.NotAPlayer.selector);
        vm.prank(bob);
        bs.cancelGame(gameId2);

        // Test that cancelled games cannot be joined (cancelled games are invalid)
        vm.expectRevert(Battleship.InvalidGameId.selector);
        vm.prank(bob);
        bs.joinGame{value: stake}(gameId, mockBoardProof());
    }

    function test_WinnerPayout_FullAmount() public {
        uint256 stake = 10 ether;
        uint256 gameId = setupTwoPlayerGame(alice, bob, stake, alice);

        uint256 bobInitialBalance = bob.balance;

        // Alice forfeits, Bob wins full prize pool
        vm.prank(alice);
        bs.forfeitGame(gameId);

        // Bob receives full 20 ether (both stakes)
        assertEq(bob.balance, bobInitialBalance + (stake * 2));

        // Prize pool is emptied
        Battleship.Game memory finalGame = bs.getGameInfo(gameId);
        assertEq(finalGame.prizePool, 0);
    }

    function test_ZeroStakeGame_FullFlow() public {
        uint256 gameId = setupTwoPlayerGame(alice, bob, 0, alice);

        vm.prank(alice);
        bs.attack(gameId, 1, 2);

        respondAndCounter(gameId, bob, Battleship.Impact.MISS, 3, 4);
        respondAndCounter(gameId, alice, Battleship.Impact.HIT, 5, 6);
        respondAndCounter(gameId, bob, Battleship.Impact.MISS, 7, 8);

        uint256 aliceInitialBalance = alice.balance;
        uint256 bobInitialBalance = bob.balance;

        // Alice forfeits
        vm.prank(alice);
        bs.forfeitGame(gameId);

        // No ETH changes hands
        assertEq(alice.balance, aliceInitialBalance);
        assertEq(bob.balance, bobInitialBalance);

        // But game still ends properly
        assertTrue(bs.isGameEnded(gameId));
        Battleship.Game memory zeroStakeGame = bs.getGameInfo(gameId);
        assertEq(zeroStakeGame.winner, bob);
    }

    function test_MultipleStakeLevels() public {
        uint256[5] memory stakes =
            [uint256(0), uint256(0.1 ether), uint256(1 ether), uint256(10 ether), uint256(50 ether)];

        for (uint256 i = 0; i < stakes.length; i++) {
            uint256 gameId = setupTwoPlayerGame(alice, bob, stakes[i], alice);
            uint256 bobInitialBalance = bob.balance;

            vm.prank(alice);
            bs.forfeitGame(gameId);

            // Verify correct payout
            assertEq(bob.balance, bobInitialBalance + (stakes[i] * 2));
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // Stress Tests
    // ═══════════════════════════════════════════════════════════════════

    function test_MaximumGameSequence() public {
        uint256 gameId = setupTwoPlayerGame(alice, bob, 1 ether, alice);

        vm.prank(alice);
        bs.attack(gameId, 0, 0);

        // Extended sequence of 15 respond-and-counter cycles
        respondAndCounter(gameId, bob, Battleship.Impact.MISS, 1, 1);
        respondAndCounter(gameId, alice, Battleship.Impact.HIT, 2, 2);
        respondAndCounter(gameId, bob, Battleship.Impact.MISS, 3, 3);
        respondAndCounter(gameId, alice, Battleship.Impact.HIT, 4, 4);
        respondAndCounter(gameId, bob, Battleship.Impact.SUNK, 5, 5);
        respondAndCounter(gameId, alice, Battleship.Impact.MISS, 6, 6);
        respondAndCounter(gameId, bob, Battleship.Impact.HIT, 7, 7);
        respondAndCounter(gameId, alice, Battleship.Impact.MISS, 8, 8);
        respondAndCounter(gameId, bob, Battleship.Impact.HIT, 9, 9);
        respondAndCounter(gameId, alice, Battleship.Impact.MISS, 0, 1);
        respondAndCounter(gameId, bob, Battleship.Impact.HIT, 1, 0);
        respondAndCounter(gameId, alice, Battleship.Impact.SUNK, 2, 0);
        respondAndCounter(gameId, bob, Battleship.Impact.MISS, 0, 2);
        respondAndCounter(gameId, alice, Battleship.Impact.HIT, 3, 1);
        respondAndCounter(gameId, bob, Battleship.Impact.MISS, 1, 3);

        // Verify game is still consistent after extended play
        assertTrue(bs.isGameStarted(gameId));
        assertFalse(bs.isGameEnded(gameId));

        Battleship.Game memory extendedGame = bs.getGameInfo(gameId);
        assertEq(extendedGame.prizePool, 2 ether);
        assertEq(extendedGame.lastPlayer, bob);
    }

    function test_AlternatingImpactTypes() public {
        uint256 gameId = setupTwoPlayerGame(alice, bob, 1 ether, alice);

        // Initial attack
        vm.prank(alice);
        bs.attack(gameId, 0, 0);

        // Execute alternating impact pattern explicitly
        respondAndCounter(gameId, bob, Battleship.Impact.MISS, 1, 1); // i=0, bob
        respondAndCounter(gameId, alice, Battleship.Impact.HIT, 2, 2); // i=1, alice
        respondAndCounter(gameId, bob, Battleship.Impact.SUNK, 3, 3); // i=2, bob
        respondAndCounter(gameId, alice, Battleship.Impact.MISS, 4, 4); // i=3, alice
        respondAndCounter(gameId, bob, Battleship.Impact.HIT, 5, 5); // i=4, bob
        respondAndCounter(gameId, alice, Battleship.Impact.SUNK, 6, 6); // i=5, alice

        // Verify game completed the sequence
        Battleship.Game memory alternatingGame = bs.getGameInfo(gameId);
        assertEq(alternatingGame.lastShotX, 6); // Last i+1 is 6 (i=5, so i+1=6)
        assertEq(alternatingGame.lastShotY, 6);
    }

    function test_AutomaticGameEndWhenEliminated() public {
        uint256 gameId = setupTwoPlayerGame(alice, bob, 2 ether, alice);

        vm.prank(alice);
        bs.attack(gameId, 5, 5);

        // Player2 responds with ship sunk, but still has ships remaining (alice is now lastPlayer)
        respondAndCounterWithShips(gameId, bob, Battleship.Impact.SUNK, 1, 1, 3); // 3 ships left
        assertFalse(bs.isGameEnded(gameId));

        // Player1 responds with ship sunk, bob still has ships (bob is now lastPlayer)
        respondAndCounterWithShips(gameId, alice, Battleship.Impact.SUNK, 2, 2, 2); // 2 ships left
        assertFalse(bs.isGameEnded(gameId));

        // Player2 responds with ship sunk, alice still has ships (alice is now lastPlayer)
        respondAndCounterWithShips(gameId, bob, Battleship.Impact.SUNK, 3, 3, 1); // 1 ship left
        assertFalse(bs.isGameEnded(gameId));

        // Player1 sinks bob's final ship - game should end automatically
        uint256 aliceBalanceBeforeFinal = alice.balance;
        uint256 bobBalanceBeforeFinal = bob.balance;

        respondAndCounterWithShips(gameId, alice, Battleship.Impact.SUNK, 4, 4, 0); // 0 ships left - GAME OVER

        // Verify game ended correctly
        assertTrue(bs.isGameEnded(gameId));
        Battleship.Game memory eliminatedGame = bs.getGameInfo(gameId);
        assertEq(eliminatedGame.prizePool, 0); // Prize pool should be emptied

        // The winner should be the attacker (lastPlayer), which is Bob
        assertEq(eliminatedGame.winner, bob);

        // Verify Bob (the winner) received full payout (4 ether total)
        assertEq(bob.balance, bobBalanceBeforeFinal + 4 ether);
        assertEq(alice.balance, aliceBalanceBeforeFinal);
    }

    // ═══════════════════════════════════════════════════════════════════
    // Scenario-Based Tests Using GameScenarios
    // ═══════════════════════════════════════════════════════════════════

    function test_ScenarioBasedGameplay() public {
        uint256 gameId = setupTwoPlayerGame(alice, bob, 1 ether, alice);

        vm.prank(alice);
        bs.attack(gameId, 5, 5);

        respondAndCounter(gameId, bob, Battleship.Impact.HIT, 2, 3);
        respondAndCounter(gameId, alice, Battleship.Impact.MISS, 7, 1);
        respondAndCounter(gameId, bob, Battleship.Impact.SUNK, 8, 2);

        // Verify the game progressed as expected
        assertFalse(bs.isGameEnded(gameId));

        // Check the last shot coordinates
        Battleship.Game memory scenarioGame = bs.getGameInfo(gameId);
        assertEq(scenarioGame.lastShotX, 8);
        assertEq(scenarioGame.lastShotY, 2);
    }

    function test_ShipPlacementValidation() public {
        // Create games to test ship placement validation
        vm.prank(alice);
        uint256 gameId1 = bs.createGame{value: 1 ether}(mockBoardProof());

        vm.prank(bob);
        uint256 gameId2 = bs.createGame{value: 1 ether}(mockBoardProof());

        vm.prank(charlie);
        uint256 gameId3 = bs.createGame{value: 1 ether}(mockBoardProof());

        // All should be valid
        assertTrue(bs.isGameValid(gameId1));
        assertTrue(bs.isGameValid(gameId2));
        assertTrue(bs.isGameValid(gameId3));
    }

    // ═══════════════════════════════════════════════════════════════════
    // End-to-End Integration
    // ═══════════════════════════════════════════════════════════════════

    function test_FullGameLifecycle() public {
        // Document a complete game from creation to end
        uint256 stake = 5 ether;

        // Phase 1: Game Creation
        vm.expectEmit(true, true, false, true);
        emit Battleship.GameCreated(0, alice);

        uint256 gameId = createGame(alice, stake);
        assertEq(bs.nextGameId(), 1);

        // Phase 2: Player Joining
        vm.expectEmit(true, true, false, true);
        emit Battleship.PlayerJoined(gameId, bob);

        vm.expectEmit(true, false, false, true);
        emit Battleship.GameStarted(gameId);

        vm.prank(bob);
        bs.joinGame{value: stake}(gameId, mockBoardProof());

        // Phase 3: Gameplay - explicit move sequence
        (address alice, address bob) = getGamePlayers(gameId);

        vm.prank(alice);
        bs.attack(gameId, 1, 1);

        respondAndCounter(gameId, bob, Battleship.Impact.MISS, 2, 2);
        respondAndCounter(gameId, alice, Battleship.Impact.HIT, 3, 3);
        respondAndCounter(gameId, bob, Battleship.Impact.MISS, 4, 4);
        respondAndCounter(gameId, alice, Battleship.Impact.HIT, 5, 5);
        respondAndCounter(gameId, bob, Battleship.Impact.SUNK, 6, 6);
        respondAndCounter(gameId, alice, Battleship.Impact.MISS, 7, 7);
        respondAndCounter(gameId, bob, Battleship.Impact.HIT, 8, 8);

        // Phase 4: Game Resolution
        uint256 winnerInitialBalance = bob.balance;

        vm.expectEmit(true, true, false, true);
        emit Battleship.GameEnded(gameId, bob);

        vm.prank(alice);
        bs.forfeitGame(gameId);

        // Phase 5: Verification
        assertTrue(bs.isGameEnded(gameId));
        assertEq(bob.balance, winnerInitialBalance + (stake * 2));

        // Get game state
        Battleship.Game memory lifecycleGame = bs.getGameInfo(gameId);

        assertEq(lifecycleGame.prizePool, 0);
        assertEq(lifecycleGame.winner, bob);
    }
}
